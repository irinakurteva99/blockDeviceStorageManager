Error codes:
1) wrong script usage
2) error when opening the file named in BDSM_FS variable
3) error in write when using the print function - mostly used for printing on stdout or file descriptor 1
4) error locating a datablock
5) error locating an inode
6) error during reading from the file which contains the virtual fileSystem
7) error during writing to the file which contains the virtual fileSystem
8) error during seeking in the file which contains the virtual fileSystem 
9) directory name already used
10) corrupted file system
11) no more free inodes
12) invalid path for the virtual fileSystem entered
13) file name too long
14) no more free space in a directory
15) error opening the file from the real file system for reading
16) error opening the file from the real file system for writing
17) trying to copy too big file in the virtual fileSystem 
18) using nonexistant file from the virtual fileSystem
19) error writing to file from real fileSystem
20) error reading from file from real fileSystem
21) trying to delete either an non-empty dir or non-dir
22) error during deletion

Структури за Superblock, Inode и Datablock:
-Superblock: съдържа полета за тип на файловата система - не се използва, 
 но пръсъства във различните съществуващи видове файлови системи, затова и го 
 добавих, за брой на inode-ите във файловата система и броя на използваните от тях,
 за броя datablock-ове и отново колко са използвани, за първия свободен inode и 
 datablock, като тези полета са със знак, тъй като ми е необходима -1 като невалидна
 стойност, за размера на файловата система, за броя inodes в един datablock, което
 се използва при пресмятане позицията на даден inode или datablock, тъй като има
 offset понякога и за check сумата, която е изчислена чраз алгоритъма на Флетчър

 Забележка: по-надолу в кода на места използвам формата uint16_t за достъп до даден inode
 или datablock вместо int32_t, но това в повечето случаи е след проверка дали даденото
 число е валидно и съответно и кастването е валидно

-Inode: съдържа полета за тип - файл или директория, ид на inode-а, ид на потребител и
 група, права за достъп, reserved (от условието), масив с datablocks - идея за подобрение - 
 добавяне на indirect datablocks, време на промяна, следващия свободен inode - използва
 се при алокирането на inode, за по-лесно следене на кой inode трябва да бъде заделен, 
 а също при освобождаване би било полезно да не сме зависими от последователността
 на айнодите в паметта, полето размер е последно и показва размера на файла

-Datablock: съдължа блок с данни и номер на следващия свободен datablock, като при записване
 на данни в блока, тази структура се игнорира и се използват всичките dbsize байтове за 
 записване на данни

-DirectoryRow: представянето на данните в дадена директория е като таблица от вида
 номер на inode:име на файла, затова и съществува тази структура. Името е с ограничена
 дължина, в случая 60 символа – хубаво е размера на тази структура да дели размера
 на един datablock, тъй като при изчисленията надолу разчитам на това и не съм смятала
 offsets. Идея за подобрение - за безкрайни имена може просто да заделим още един inode
 със съответсващите му datablocks(ако са нужни). Вместо име на файла, може да помним номера
 на този inode, а името да са данните, записани в него.

Ще започна описанието си от главните функции, а не по реда, в който са написани в кода

MKFS: създава основната структура на файловата система. За вземане на размера на файла
използвах 1). След това отварям файла в режим за писане и след това изтривам цялото съдължание на файла с O_TRUNC.
Създавам обект от тип superblock и пресмятам, ако на 2000 байта заделям по 1 inode, 
колко inode-a биха били необходими. Създавам суперблока с първоначани стойности, като броят 
на datablocks се смята като от общия брой datablocks, които съответсват на дадения размер
на файла изваждам 1 datablock за суперблока и още n на брой за inodes, като деленето при
superblock.inodesPerDatablock е целочислено, т.е. всеки inode попада в даден datablock, 
няма inode, който да е наполовина в единия, наполовина в другия datablock. Checksum е изчислена
по алгоритъма на Флетчър - 2). Функциите safeRead, safeWrite и safeLseek съответстват на 
read, write и lseek, с разликата, че проверяват дали операцията се е изпълнина успешно и
извикват err и затварят файловия дескриптор, който им е подаден, при неуспешно изпълнение.
След това записвам суперблока и се вика функцията, която записва inode-и с някаква стойнст
по подразбиране - writeInodes. В нея първо отиваме до позицията на първия inode, т.е 
прискачам датаблока за суперблока и след това просто последователно записвам n на брой 
inodes, като на всеки inodesPerDatablock на брой inode-a ми трябва offset, за да не се 
получи това разделяне на inode на две части, което описах по-горе. Следващата функция е 
writeDatablocks, която дори е по-лесна от writeInodes, тъй като не се налага да добавя offset.
Функцията allocateInode се използва за алокиране на следващия свобовен inode, като в случая
заделя този с номер 0 за +. Тя проверява дали се опитаваме да заделим валиден или невалиден inode -
невалиден ще е при изчерпване на всички inodes. След това прочита inode-a на дадената позиция, за
да разберем кой е следващият свободен, който вече ще е първият свободен и преизчисляване checkSum на
суперблока, като нулираме chekcSum, тъй като ако отчитаме старата й стойност, няма да има 
консистентност при изчислението на Fletcher16 върху текущия суперблок, дори без да променяме
данните му. Следващата стъпка е да намерим inode-a и суперблока и да ги презапишем с новите стойности.
locateInode и locateDatablock функциите се използват за по-лесно намиране на позицията на даден 
inode или datablock и пестят постоянни еднотипни сметки - за да намерим позицията на datablock
просто прескачаме 1 + броя datablocks заети от inodes + db (броим от 0, т.е за да стигнем
datablock 1 трябва да прескочим 1 - нулевия). При locateInode изчисляваме първо на коя позиция
се намира datablock-a, в който е текущият inode и после позицията, на която се намира inode-a
в текущия блок. Например, ако има 40 inodes в datablock и ние искаме да стигнем до inode 70, то
той ще се намира в 70/40 = datablock 1 - ако не броим този за суперблока и следващите ги броим
от 0, на позиция 70%40 = 30 - отново при броене от 0 - inode 40 се намира в datablock 1 на 
позиция 0. Следващата част от кода се използваше основно за дебъгване, затова и е в коментар - при
нужда може да се премахне коментара, за да се види, че данните записани в суперблока и първия 
inode са очакваните, тогава трябва да бъде сменен и режима, в който се отваря файла, на O_RDWR.

DEBUG: отварям файла, записан в BDSM_FS, чета суперблока от него и принтирам метаданните
на конзолата. Тези данни са за размера на файловата система, типа й, броя inodes и колко
от тях са използвани, колко е общият брой datablocks и колко от тях са използвани, също
така размера на един inode и datablock.

FSCK: проверява за коректност файловата система - преизчислява FletcherCheckSum и сравнява
новата стойност със записаната в суперблока, след това минава по веригата на свободните
inodes и datablocks и проверява дали броят им съответства на записания в суперблока - 
общият брой - броя използвани. Ако всичко е наред, връща съобщение, в противен случай
хвърля грешка по време на изпълнението. 
 
MKDIR: първата стъпка е валидацията на подадения път - дали отговаря на изискванията, описани
в условието - това се извършва от функцията validatePath - ако дължината на пътя е под 2 или не 
започва от root директорията е невалиден, също така ако съдържа символ, различен от описаните
в problem.txt или ако завършва на '/'. След като знам, че подаденият път е валиден, трябва да 
намерим името на директорията, която искаме да добавим, затова е и следващият цикъл. След това
се извиква функцията addDirToDir. В тази функция се отделя името на родителската директория (goTO)
и името на текущата директорията, която искаме да добавим. Вика се функцията goToDir с goTo. Целта 
на тази функцията е да върне номера на inode-a на директорията, чиито път е подаден като параметър
на path параметъра. Ако path съвпада с +/, то връщаме 0, което е номерът на inode на root
директорията. В противен случай викаме функцията locateDir за всяка поддиректория – стринга между 2 наклонени
черти и след последната наклонена черта. На locateDir й подаваме името на текущата дируктория, 
която търсим и номерът на inode-а на родителя й. За всеки записан ред в директорията проверяваме
дали името, записано на текущия ред, съвпада с подаденото име и ако да, връщаме inode-a, в противен случай 
връщаме -1, ако в крайна сметка сме намерили родителската директория и по-точно номера на 
inode-a й, проверяваме дали в нея има директория с име като това, което се опитваме да добавим. Ако няма,
се връщаме в addDirToDir като вече знаем името на новата директория и inode-a на тази, в която ще добавяме.
Проверяваме дали има място в текущия datablock и ако да, не заделяме нов, ако за пръв път ще добавяме
в тази дируктория или предишния datablock се е запълнил, заделяме нов datablock и lseek-ваме до
началото му, за да пишем там. Записваме в дадения datablock името на inode-a, който ще съответства на 
новата директория и името й и обновяваме суперблока.

LSDIR: намираме директорията, на която съответства подадения път и прочитаме данните, записани
в inode-a. За всеки от записаните редове в тази директория, принтираме данните му - т.е 
вземаме номера на inode-a и името, от inode-a принтираме правата за достъп и username и group. 
След това използваме 4), за да принтираме времето в описания в problem.txt формат и 
най-накрая печатаме и името на самия файл/директория, който съответства на текущия ред.

LSOBJ: аналогично на lsdir намираме inode-a на обекта, съответстващ на path. След това
печатаме данните за този inode, използвайки функциите, които се ползват и при lsdir, но този
път ги викаме еднократно с дадения inode, a не за всеки ред в данните на текущия inode. Накрая
използвам логика като при mkdir, за да взема името на файла, за който извеждаме информация, като 
ако това име е празно, значи е подадена + директорията и печатам + като име.

CPFILE: /path/to/file +/path/to/file
  Първо вземам размера на файла, който ще искаме да копираме във въртуалната файлова система, след
това аналогично на mkdir заделяме в директорията, която искаме да добавим, ред за новия файл. След това
отиваме до inode-a на новия файл и записаваме в datablock-овете му данните от външния файл. Като ако
размерът на файла не е кратен на dbsize, последните х байта ги записваме отделно, за да не записваме на блокове
по 512. За permissions използвах 5), за да видя как се взимат и ги задавам в inode-a. Накрая презаписвам 
inode-a и суперблока. Акофайла съществува, освобождавам заетите datablock-ове, и записвам във файла 
все едно е празен и тепърва му заделяме inode.

        +/path/to/file /path/to/file
  Локализираме файла във виртуалната файлова система, после четем datablock-овете му и записвам
данните във файла, като ако не съществува, го създаваме. Отново като в cpfile +/.. /.., 
ако данните не са кратни на dbsize, четем от последния датаблок единствено записаните данни там. 

STAT: опитах се да възпроизведа нещо максимелно близко до реалната команда stat и съответно
принтирам данните, които присъстват в моята файлова система - името на файла, типа - directory или
regular file, размера, кой inode съответства на дадения файл, UID и GID, правата за достъп в числов 
формат, за да се различава от lsobj и modification time. 

RMDIR: прави проверка дали директорията, която се опитваме да изтрием съществува и дали е празна.
Ако отговаря на изискванията, използвам логиката от предишните функции за да намеря
къде в родителската й директория се намира. Засега bdsm.c може да изтрие само директорията, намираща
се на последно място в родителската си, като изтрива заделения за тази директория inode
и ако се освобождава datablock в родителската директория - изтрива и него

0)https://stackoverflow.com/questions/9990214/get-environment-variables-using-c-code
1)https://stackoverflow.com/questions/238603/how-can-i-get-a-files-size-in-c
2)https://en.wikipedia.org/wiki/Fletcher%27s_checksum
3)допълнение към 4)https://en.cppreference.com/w/c/chrono/strftime
4)https://en.wikipedia.org/wiki/C_date_and_time_functions
5)https://stackoverflow.com/questions/10323060/printing-file-permissions-like-ls-l-using-stat2-in-c
